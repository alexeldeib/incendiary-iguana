/*
Copyright 2019 Alexander Eldeib.
*/

package controllers

import (
	"context"
	"errors"
	"net/http"

	"github.com/Azure/azure-sdk-for-go/services/keyvault/v7.0/keyvault"
	"github.com/go-logr/logr"
	corev1 "k8s.io/api/core/v1"
	apierrs "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	azurev1alpha1 "github.com/alexeldeib/incendiary-iguana/api/v1alpha1"
	"github.com/alexeldeib/incendiary-iguana/pkg/clients/secrets"
)

const autogenerated = "autogenerated"

// SecretReconciler reconciles a Secret object
type SecretReconciler struct {
	client.Client
	Log           logr.Logger
	SecretsClient secrets.Client
	Scheme        *runtime.Scheme
}

type SecretRequestArgs struct {
	Secret        *azurev1alpha1.Secret
	Local         *corev1.Secret
	Remote        keyvault.SecretBundle
	LastKnownName string
	Log           logr.Logger
}

// +kubebuilder:rbac:groups=azure.alexeldeib.xyz,resources=secrets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=azure.alexeldeib.xyz,resources=secrets/status,verbs=get;update;patch

func (r *SecretReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
	ctx := context.Background()
	log := r.Log.WithValues("secret", req.NamespacedName)

	var secret azurev1alpha1.Secret
	var local corev1.Secret
	var remote keyvault.SecretBundle
	var err error

	if err = r.Get(ctx, req.NamespacedName, &secret); err != nil {
		log.Info("error during get crd")
		return ctrl.Result{Requeue: !apierrs.IsNotFound(err)}, client.IgnoreNotFound(err)
	}

	if remote, err = r.SecretsClient.Get(ctx, &secret); err != nil {
		log.Info("error during get remote")
		return ctrl.Result{}, err
	}

	if local, err = r.getLocal(ctx, &secret, log); err != nil {
		log.Info("error during get local")
		return ctrl.Result{}, err
	}

	if err = r.sync(ctx, &secret, &remote, &local, log); err != nil {
		log.Info("error during sync")
		return ctrl.Result{}, err
	}

	if err = r.deleteExternal(ctx, &secret, &remote, &local, log); err != nil {
		log.Info("error during delete external")
		return ctrl.Result{}, err
	}

	if err = r.reconcileExternal(ctx, &secret, &remote, &local, log); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

func (r *SecretReconciler) getLocal(ctx context.Context, secret *azurev1alpha1.Secret, log logr.Logger) (corev1.Secret, error) {
	var local corev1.Secret
	name := overrideName(secret, &local)
	err := r.Get(ctx, name, &local)
	return local, client.IgnoreNotFound(err)
}

func overrideName(secret *azurev1alpha1.Secret, local *corev1.Secret) types.NamespacedName {
	name := types.NamespacedName{
		Name:      secret.Spec.Name,
		Namespace: secret.ObjectMeta.Namespace,
	}
	local.ObjectMeta.Name = secret.Spec.Name
	local.ObjectMeta.Namespace = secret.ObjectMeta.Namespace
	if secret.Spec.LocalName != nil {
		name.Name = *secret.Spec.LocalName
		local.ObjectMeta.Name = *secret.Spec.LocalName
	}
	return name
}

// Sync sets the status on the object reconciled in this loop, and updates it in the API server.
func (r *SecretReconciler) sync(ctx context.Context, secret *azurev1alpha1.Secret, remote *keyvault.SecretBundle, local *corev1.Secret, log logr.Logger) error {
	syncRemote(secret, remote, log)
	syncLocal(secret, local, log)
	secret.Status.Generation = secret.ObjectMeta.Generation
	return r.Status().Update(ctx, secret)
}

func syncRemote(secret *azurev1alpha1.Secret, remote *keyvault.SecretBundle, log logr.Logger) {
	if remote.IsHTTPStatus(http.StatusNotFound) {
		log.Info("keyvault secret not found")
		secret.Status.Exists = false
	} else {
		secret.Status.Exists = true
	}
}

func syncLocal(secret *azurev1alpha1.Secret, local *corev1.Secret, log logr.Logger) {
	log.Info("syncing local")
	if local.Data == nil || len(local.Data) == 0 {
		log.Info("corresponding kubernetes secret not found")
		secret.Status.Available = false
	} else {
		log.Info("found local")
		secret.Status.Available = true
	}
}

// reconcileExternal handles the primary create/update control loop.
func (r *SecretReconciler) reconcileExternal(ctx context.Context, secret *azurev1alpha1.Secret, remote *keyvault.SecretBundle, local *corev1.Secret, base logr.Logger) error {
	log := base.WithValues("func", "reconcileExternal")
	if secret.Status.Exists {
		log.Info("reconciling target secret")
		_, err := controllerutil.CreateOrUpdate(ctx, r.Client, local, func() error {
			innerErr := controllerutil.SetControllerReference(secret, local, r.Scheme)
			if innerErr != nil {
				return innerErr
			}
			// TODO(ace): check for and avoid conflicts; allow/deny overwrite from user spec
			// TODO(ace): key this off something else
			local.Data = map[string][]byte{
				local.ObjectMeta.Name: []byte(*remote.Value),
			}
			return nil
		})
		if err != nil {
			return err
		}
		if err = r.deleteOld(ctx, secret, local, log); err != nil {
			return err
		}
		secret.Status.LastKnownName = local.ObjectMeta.Name
		return r.Status().Update(ctx, secret)
	}
	// TODO(ace): If it doesn't exist, generate it (requires input metadata)
	// TODO(ace): create the necessary Keyvault if it doesn't exist
	return errors.New("keyvault secret not found")
}

// deleteOld handles deletion of secrets after a rename of the item.
func (r *SecretReconciler) deleteOld(ctx context.Context, secret *azurev1alpha1.Secret, local *corev1.Secret, base logr.Logger) error {
	log := base.WithValues("func", "deleteOld")
	if secret.Status.Available && secret.Status.LastKnownName != "" && secret.Status.LastKnownName != local.ObjectMeta.Name {
		old := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      secret.Status.LastKnownName,
				Namespace: secret.ObjectMeta.Namespace,
			},
		}
		log.Info("name changed; attempting to delete old secret")
		if err := r.Delete(ctx, old); err != nil && !apierrs.IsNotFound(err) {
			log.Info("failed to delete old secret")
			return err
		}
		log.Info("finished deleting old secret after name change")
	}
	return nil
}

func (r *SecretReconciler) deleteLocal(ctx context.Context, secret *azurev1alpha1.Secret, local *corev1.Secret) error {
	if secret.Status.Available {
		return DeleteIfFound(ctx, r.Client, local)
	}
	return nil
}

func (r *SecretReconciler) deleteRemote(ctx context.Context, secret *azurev1alpha1.Secret, remote *keyvault.SecretBundle, isAutogenerated bool) error {
	// TODO(ace): if a Keyvault exists and has the annotation "managed", delete it
	// If the Azure secret exists and has the tag "autogenerated", delete it.
	// This would naturally be done as part of Keyvault deletion if using a managed Keyvault.
	if secret.Status.Exists && isAutogenerated {
		if err := r.SecretsClient.Delete(ctx, secret); err != nil {
			return err
		}
	}
	return nil
}

// deleteExternal handles the delete control loop.
func (r *SecretReconciler) deleteExternal(ctx context.Context, secret *azurev1alpha1.Secret, remote *keyvault.SecretBundle, local *corev1.Secret, base logr.Logger) error {
	log := base.WithValues("func", "deleteExternal")
	log.Info("")
	if !secret.ObjectMeta.DeletionTimestamp.IsZero() {
		if contains(secret.ObjectMeta.Finalizers, finalizerName) {
			// If the Kubernetes secret exists, delete it.
			log.Info("Inner deletion loop of external secret")
			if err := r.deleteLocal(ctx, secret, local); err != nil {
				log.Info("failed deletion of Kubernetes secret")
				return err
			}
			_, isAutogenerated := remote.Tags[autogenerated]
			if err := r.deleteRemote(ctx, secret, remote, isAutogenerated); err != nil {
				log.Info("failed deletion of Keyvault secret")
				return err
			}
			if !secret.Status.Available && (!secret.Status.Exists || !isAutogenerated) {
				log.Info("finished deletion of secret")
				return RemoveFinalizerAndUpdate(ctx, r.Client, finalizerName, secret)
			}
			return errors.New("should requeue")
		}
	}
	return nil
}

func (r *SecretReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&azurev1alpha1.Secret{}).
		Owns(&corev1.Secret{}).
		Complete(r)
}
