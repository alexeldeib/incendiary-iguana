/*
Copyright 2019 Alexander Eldeib.
*/

package controllers

import (
	"context"
	"net/http"

	"github.com/Azure/azure-sdk-for-go/services/keyvault/v7.0/keyvault"
	"github.com/go-logr/logr"
	"github.com/prometheus/common/log"
	corev1 "k8s.io/api/core/v1"
	apierrs "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	azurev1alpha1 "github.com/alexeldeib/incendiary-iguana/api/v1alpha1"
	"github.com/alexeldeib/incendiary-iguana/pkg/clients/secrets"
)

const autogenerated = "autogenerated"

// SecretReconciler reconciles a Secret object
type SecretReconciler struct {
	client.Client
	Log           logr.Logger
	SecretsClient secrets.Client
	Scheme        *runtime.Scheme
}

// +kubebuilder:rbac:groups=azure.alexeldeib.xyz,resources=secrets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=azure.alexeldeib.xyz,resources=secrets/status,verbs=get;update;patch

func (r *SecretReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
	ctx := context.Background()
	log := r.Log.WithValues("secret", req.NamespacedName)

	var secret *azurev1alpha1.Secret
	var localsecret *corev1.Secret
	var remotesecret keyvault.SecretBundle

	if err := r.Get(ctx, req.NamespacedName, secret); err != nil {
		// dont't requeue not found
		if apierrs.IsNotFound(err) {
			return ctrl.Result{}, nil
		}
		log.Error(err, "unable to fetch secret")
		return ctrl.Result{}, err
	}

	if remotesecret, err := r.SecretsClient.Get(ctx, secret); err != nil {
		if !remotesecret.IsHTTPStatus(http.StatusNotFound) {
			return ctrl.Result{}, err
		}
	}

	if err := r.Get(ctx, req.NamespacedName, localsecret); err != nil && !apierrs.IsNotFound(err) {
		return ctrl.Result{}, err
	}

	if err := r.Status().Update(ctx, secret); err != nil {
		return ctrl.Result{}, err
	}

	// Handle deletion/finalizer
	if secret.ObjectMeta.DeletionTimestamp.IsZero() {
		AddFinalizer(secret, finalizerName)
		if err := r.Update(ctx, secret); err != nil {
			return ctrl.Result{}, err
		}
	} else {
		// The object is being deleted
		if containsString(secret.ObjectMeta.Finalizers, finalizerName) {
			log.Info("deleting")
			if err := r.deleteExternal(ctx, remotesecret, localsecret, secret); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	log.Info("reconciling secret")
	if err := r.reconcileExternal(ctx, remotesecret, localsecret, secret); err != nil {
		return ctrl.Result{}, err
	}
	return ctrl.Result{}, nil
}

func (r *SecretReconciler) updateStatus(ctx context.Context, namespaceName types.NamespacedName, remotesecret keyvault.SecretBundle, localsecret *corev1.Secret, secret *azurev1alpha1.Secret) {
	if remotesecret.IsHTTPStatus(http.StatusNotFound) {
		log.Info("keyvault secret not found")
		secret.Status.Exists = false
	} else {
		secret.Status.Exists = true
	}

	if localsecret != nil {
		log.Info("corresponding kubernetes secret not found")
		secret.Status.Available = false
	} else {
		secret.Status.Available = true
	}

	secret.Status.Generation = secret.ObjectMeta.GetGeneration()
}

func (r *SecretReconciler) reconcileExternal(ctx context.Context, remotesecret keyvault.SecretBundle, localsecret *corev1.Secret, secret *azurev1alpha1.Secret) error {
	// If the external secret exists, sync it to Kubernetes
	if secret.Status.Exists {
		secretValue := *remotesecret.Value
		// Create or mutate
		_, err := controllerutil.CreateOrUpdate(ctx, r.Client, localsecret, func() error {
			localsecret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      secret.Spec.Name,
					Namespace: secret.ObjectMeta.GetNamespace(),
				},
			}
			if secret.Spec.LocalName != nil {
				localsecret.Name = *secret.Spec.LocalName
			}
			// Attempt to find an owner ref matching our controller..
			innerErr := controllerutil.SetControllerReference(secret, localsecret, r.Scheme) //nolint:ineffassign
			if innerErr != nil {
				return innerErr
			}

			// Initialize data if necessary, and set desired key.
			if localsecret.Data == nil {
				localsecret.Data = map[string][]byte{}
			}
			// TODO(ace): key this off something else
			// TODO(ace): check for and avoid conflicts; allow/deny overwrite from user spec
			localsecret.Data[secret.Spec.Name] = []byte(secretValue)
			return nil
		})
		return err
	}

	// TODO(ace): If it doesn't exist, generate it (requires input metadata)
	// TODO(ace): create the necessary Keyvault if it doesn't exist
	return nil
}

func (r *SecretReconciler) deleteExternal(ctx context.Context, remotesecret keyvault.SecretBundle, localsecret *corev1.Secret, secret *azurev1alpha1.Secret) error {
	// If the Kubernetes secret exists, delete it.
	if secret.Status.Available {
		if err := r.Delete(ctx, localsecret); err != nil {
			log.Info("failed deletion of Kubernetes secret")
			return err
		}
	}

	// TODO(ace): if a Keyvault exists and has the annotation "managed", delete it
	// If the Azure secret exists and has the tag "autogenerated", delete it.
	// This would naturally be done as part of Keyvault deletion if using a managed Keyvault.
	_, isAutogenerated := remotesecret.Tags[autogenerated]
	if secret.Status.Exists && isAutogenerated {
		if err := r.SecretsClient.Delete(ctx, secret); err != nil {
			log.Info("failed deletion of Keyvault secret")
			return err
		}
	}

	if !secret.Status.Available && (!secret.Status.Exists || !isAutogenerated) {
		log.Info("finished deletion of secret")
		RemoveFinalizer(secret, finalizerName)
	}

	if err := r.Update(ctx, secret); err != nil {
		log.Info("failed update after deletion loop")
		return err
	}
	return nil
}

// Fetch retrieves an object by namespaced name from the API server and puts the contents in the runtime.Object parameter.
// TODO(ace): refactor onto base reconciler struct
func Fetch(ctx context.Context, client client.Client, namespacedName types.NamespacedName, obj runtime.Object, log logr.Logger) error {
	if err := client.Get(ctx, namespacedName, obj); err != nil {
		// dont't requeue not found
		if apierrs.IsNotFound(err) {
			return nil
		}
		log.Error(err, "unable to fetch secret")
		return err
	}
	return nil
}

// AddFinalizerAndUpdate removes a finalizer from a runtime object and attempts to update that object in the API server.
// It returns an error if either operation failed.
func AddFinalizerAndUpdate(ctx context.Context, client client.Client, finalizer string, o runtime.Object) error {
	m, err := meta.Accessor(o)
	if err != nil {
		return err
	}
	if contains(m.GetFinalizers(), finalizer) {
		return nil
	}
	AddFinalizer(m, finalizer)
	if err := client.Update(ctx, o); err != nil {
		return err
	}
	return nil
}

// RemoveFinalizerAndUpdate removes a finalizer from a runtime object and attempts to update that object in the API server.
// It returns an error if either operation failed.
func RemoveFinalizerAndUpdate(ctx context.Context, client client.Client, finalizer string, o runtime.Object) error {
	m, err := meta.Accessor(o)
	if err != nil {
		return err
	}
	if !contains(m.GetFinalizers(), finalizer) {
		return nil
	}
	RemoveFinalizer(m, finalizer)
	if err := client.Update(ctx, o); err != nil {
		return err
	}
	return nil
}

// AddFinalizer accepts a metav1 object and adds the provided finalizer if not present.
func AddFinalizer(o metav1.Object, finalizer string) {
	f := o.GetFinalizers()
	for _, e := range f {
		if e == finalizer {
			return
		}
	}
	o.SetFinalizers(append(f, finalizer))
}

// AddFinalizerWithError tries to convert a runtime object to a metav1 object and add the provided finalizer.
// It returns an error if the provided object cannot provide an accessor.
func AddFinalizerWithError(o runtime.Object, finalizer string) error {
	m, err := meta.Accessor(o)
	if err != nil {
		return err
	}
	AddFinalizer(m, finalizer)
	return nil
}

// RemoveFinalizer accepts a metav1 object and removes the provided finalizer if present.
func RemoveFinalizer(o metav1.Object, finalizer string) {
	f := o.GetFinalizers()
	for i, e := range f {
		if e == finalizer {
			f = append(f[:i], f[i+1:]...)
			o.SetFinalizers(f)
			return
		}
	}
	return
}

// RemoveFinalizerWithError tries to convert a runtime object to a metav1 object and remove the provided finalizer.
// It returns an error if the provided object cannot provide an accessor.
func RemoveFinalizerWithError(o runtime.Object, finalizer string) error {
	m, err := meta.Accessor(o)
	if err != nil {
		return err
	}
	RemoveFinalizer(m, finalizer)
	return nil
}

func contains(vals []string, val string) bool {
	for _, v := range vals {
		if v == val {
			return true
		}
	}
	return false
}

func remove(vals []string, val string) []string {
	for i, v := range vals {
		if v == val {
			return append(vals[:i], vals[i+1:]...)
		}
	}
	return vals
}

func (r *SecretReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&azurev1alpha1.Secret{}).
		Owns(&corev1.Secret{}).
		Complete(r)
}
